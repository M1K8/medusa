package medusa

import (
	"log"
	"sync"

	"github.com/bwmarrin/discordgo"
	"github.com/m1k8/medusa/pkg/gdb"
)

type medusa struct {
	repo      *gdb.Repo
	s         *discordgo.Session
	alerterID string
}

type medusaImpl interface {
	Send(msg string, editMessage func(string, string) string) (map[string]*discordgo.MessageReference, error)
	SendEmbeds(embeds []*discordgo.MessageEmbed, editMessage func(string, []*discordgo.MessageEmbed) []*discordgo.MessageEmbed) (map[string]*discordgo.MessageReference, error)
	SendComplex(msg *discordgo.MessageSend, editMessage func(string, *discordgo.MessageSend) *discordgo.MessageSend) (map[string]*discordgo.MessageReference, error)
}

var _ medusaImpl = &medusa{}

var once sync.Once = sync.Once{}
var singleton *medusa

func GetMedusa(session *discordgo.Session, r *gdb.Repo, alerterID string) *medusa {
	once.Do(func() {
		singleton = &medusa{s: session, repo: r, alerterID: alerterID}
	})
	return singleton
}

func (t *medusa) Send(msg string, editMessage func(string, string) string) (map[string]*discordgo.MessageReference, error) {
	msgRefs := make(map[string]*discordgo.MessageReference, 0)

	allSrvrs, err := t.repo.AlerterListAllServers(t.alerterID)
	if err != nil {
		return nil, err
	}

	for k, v := range allSrvrs {
		srvrMsg := msg
		if editMessage != nil {
			srvrMsg = editMessage(k, msg)
			if srvrMsg == "" {
				continue
			}
		}
		ref, err := t.s.ChannelMessageSend(v, srvrMsg)

		if err != nil {
			log.Println("Failed to send message to " + k + ":" + v + " - " + err.Error())
			continue
		}

		if ref != nil && ref.Reference() != nil {
			msgRefs[k] = ref.Reference()
		}
	}

	return msgRefs, nil
}

func (t *medusa) SendEmbeds(embeds []*discordgo.MessageEmbed, editMessage func(string, []*discordgo.MessageEmbed) []*discordgo.MessageEmbed) (map[string]*discordgo.MessageReference, error) {
	msgRefs := make(map[string]*discordgo.MessageReference, 0)

	allSrvrs, err := t.repo.AlerterListAllServers(t.alerterID)
	if err != nil {
		return nil, err
	}

	for k, v := range allSrvrs {

		srvrEmbeds := embeds
		if editMessage != nil {
			srvrEmbeds = editMessage(k, embeds)
			if srvrEmbeds == nil || len(srvrEmbeds) == 0 {
				continue
			}
		}

		ref, err := t.s.ChannelMessageSendEmbeds(v, srvrEmbeds)

		if err != nil {
			log.Println("Failed to send message to " + k + ":" + v + " - " + err.Error())
			continue
		}

		if ref != nil && ref.Reference() != nil {
			msgRefs[k] = ref.Reference()
		}
	}

	return msgRefs, nil
}

func (t *medusa) SendComplex(msg *discordgo.MessageSend, editMessage func(string, *discordgo.MessageSend) *discordgo.MessageSend) (map[string]*discordgo.MessageReference, error) {
	msgRefs := make(map[string]*discordgo.MessageReference, 0)

	allSrvrs, err := t.repo.AlerterListAllServers(t.alerterID)
	if err != nil {
		return nil, err
	}

	for k, v := range allSrvrs {
		srvrMsg := msg
		if editMessage != nil {
			srvrMsg = editMessage(k, msg)
			if srvrMsg == nil {
				continue
			}
		}
		ref, err := t.s.ChannelMessageSendComplex(v, srvrMsg)

		if err != nil {
			log.Println("Failed to send message to " + k + ":" + v + " - " + err.Error())
			continue
		}

		if ref != nil && ref.Reference() != nil {
			msgRefs[k] = ref.Reference()
		}
	}

	return msgRefs, nil
}

/*
Single bot approach:

All tied to main Kronos instance

Posting / Subbing will be done inside the bot - whenever a user posts an alert, we check if there are any other servers that are "subscribed"
	- this will be done using ID's and tokens - tokens will be /generated by the alerter, and /subscribed by the user. Sub() will take 2 args - userID and key (this is to allow /unsubscribe to exist)
	- alerter can also /manage their lists i.e. /manage purge, /manage remove <$>
*/
